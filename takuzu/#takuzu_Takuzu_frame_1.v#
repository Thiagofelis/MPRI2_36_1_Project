(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:array a)
    (i:Numbers.BinNums.Z) : a :=
  elts a1 i.

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom mixfix_lblsmnrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((length (mixfix_lblsmnrb a1 i v)) = (length a1)) /\
  ((elts (mixfix_lblsmnrb a1 i v)) = (map.Map.set (elts a1) i v)).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   ((mixfix_lbrb (make n v) i) = v)) /\
  ((length (make n v)) = n).

Parameter us_FORMULA_TO_BE_COMPLETED__: Prop.

Parameter us_TERM_TO_BE_COMPLETED__: forall {a:Type} {a_WT:WhyType a}, a.

Parameter us_VARIANT_TO_BE_COMPLETED__: Numbers.BinNums.Z.

(* Why3 assumption *)
Inductive elem :=
  | Zero : elem
  | One : elem
  | Empty : elem.
Axiom elem_WhyType : WhyType elem.
Existing Instance elem_WhyType.

(* Why3 assumption *)
Definition takuzu_grid := array elem.

(* Why3 assumption *)
Definition row_start_index (n:Numbers.BinNums.Z) : Numbers.BinNums.Z :=
  (8%Z * (ZArith.BinInt.Z.quot n 8%Z))%Z.

(* Why3 assumption *)
Definition valid_chunk (s:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) : Prop :=
  (i = 1%Z) /\
  ((0%Z <= s)%Z /\ (s <= 56%Z)%Z) /\ ((ZArith.BinInt.Z.rem s 8%Z) = 0%Z) \/
  (i = 8%Z) /\ (0%Z <= s)%Z /\ (s <= 7%Z)%Z.

Axiom valid_chunk1 :
  forall (s:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), valid_chunk s i ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < 8%Z)%Z ->
  (0%Z <= (s + (k * i)%Z)%Z)%Z /\ ((s + (k * i)%Z)%Z < 64%Z)%Z.

(* Why3 assumption *)
Definition acc (g:array elem) (start:Numbers.BinNums.Z)
    (incr:Numbers.BinNums.Z) (k:Numbers.BinNums.Z) : elem :=
  mixfix_lbrb g (start + (incr * k)%Z)%Z.

(* Why3 assumption *)
Definition no_3_consecutive_identical_elem (g:array elem)
    (start:Numbers.BinNums.Z) (incr:Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) : Prop :=
  forall (k:Numbers.BinNums.Z),
  (0%Z <= k)%Z /\ (k < (l - 2%Z)%Z)%Z /\ ((l - 2%Z)%Z <= incr)%Z ->
  ~ ((((acc g start incr k) = (acc g start incr (k + 1%Z)%Z)) /\
      ((acc g start incr (k + 1%Z)%Z) = (acc g start incr (k + 2%Z)%Z))) /\
     (((acc g start k incr) = One) \/ ((acc g start k incr) = Zero))).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Parameter num_occ:
  elem -> array elem -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom num_occ'def :
  forall (e:elem) (g:array elem) (start:Numbers.BinNums.Z)
    (incr:Numbers.BinNums.Z) (l:Numbers.BinNums.Z),
  ((length g) = 64%Z) -> (0%Z <= l)%Z /\ (l <= 8%Z)%Z ->
  valid_chunk start incr ->
  ((l = 0%Z) -> ((num_occ e g start incr l) = 0%Z)) /\
  (~ (l = 0%Z) ->
   (((acc g start incr (l - 1%Z)%Z) = e) ->
    ((num_occ e g start incr l) =
     (1%Z + (num_occ e g start incr (l - 1%Z)%Z))%Z)) /\
   (~ ((acc g start incr (l - 1%Z)%Z) = e) ->
    ((num_occ e g start incr l) = (num_occ e g start incr (l - 1%Z)%Z)))).

(* Why3 assumption *)
Definition rule_2_for_chunk (g:array elem) (start:Numbers.BinNums.Z)
    (incr:Numbers.BinNums.Z) : Prop :=
  ((num_occ Zero g start incr 8%Z) <= 4%Z)%Z /\
  ((num_occ One g start incr 8%Z) <= 4%Z)%Z.

(* Why3 assumption *)
Definition identical_chunks (g:array elem) (s1:Numbers.BinNums.Z)
    (s2:Numbers.BinNums.Z) (incr:Numbers.BinNums.Z) (l:Numbers.BinNums.Z) :
    Prop :=
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < l)%Z ->
  ((acc g s1 incr k) = (acc g s2 incr k)) /\ ~ ((acc g s2 incr k) = Empty).

(* Why3 assumption *)
Definition rule_1_for_cell (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  no_3_consecutive_identical_elem g (ZArith.BinInt.Z.rem n 8%Z) 8%Z 8%Z /\
  no_3_consecutive_identical_elem g (row_start_index n) 1%Z 8%Z.

(* Why3 assumption *)
Definition rule_2_for_cell (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  no_3_consecutive_identical_elem g (ZArith.BinInt.Z.rem n 8%Z) 8%Z 8%Z /\
  no_3_consecutive_identical_elem g (row_start_index n) 1%Z 8%Z.

(* Why3 assumption *)
Definition rule_3_for_cell (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  let cs := ZArith.BinInt.Z.rem n 8%Z in
  let rs := row_start_index n in
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 8%Z)%Z ->
  ((i = cs) \/ ~ identical_chunks g cs i 8%Z 8%Z) /\
  (((8%Z * i)%Z = rs) \/ ~ identical_chunks g rs (i * 8%Z)%Z 1%Z 8%Z).

(* Why3 assumption *)
Definition valid_for_cell (g:array elem) (i:Numbers.BinNums.Z) : Prop :=
  rule_1_for_cell g i /\ rule_2_for_cell g i /\ rule_3_for_cell g i.

(* Why3 assumption *)
Definition valid_up_to (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
  valid_for_cell g i.

(* Why3 goal *)
Theorem frame :
  forall (g1:array elem) (g2:array elem) (n:Numbers.BinNums.Z) (e:elem)
    (ee:elem),
  ((length g2) = (length g1)) /\ ((length g1) = 64%Z) ->
  (0%Z <= n)%Z /\ (n < 64%Z)%Z ->
  ((mixfix_lblsmnrb (mixfix_lblsmnrb g1 n e) n ee) =
   (mixfix_lblsmnrb g2 n ee)).
Proof.
intros g1 g2 n e ee (h1,h2) (h3,h4).
simpl. reflexivity.
Qed.

